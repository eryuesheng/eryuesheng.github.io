---
layout:     post
title:      python3.8 面向对象编程
subtitle:   Python面向对象
date:       2020-6-4
author:     ErYueSheng
header-img: img/post-sample-image.jpg
catalog:    true
tags:
    - 面向对象
    - python
---

>万物皆对象---------------这句话第一次听说是在Java里面

# Python面向对象编程

像C语言这样的程序，主要是面向过程的，所谓过程就是一堆指令的集合，而函数就是过程的封装，一个函数代表一个过程，大函数可以包含小函数。

而面向对象就是认为所有的东西都是对象，对象有啥特点呢，就是有属性（数据）也有操作（方法），一个对象可以访问另一个对象。如果你想要知道某个属性（数据），那你就直接问相应的对象，因为最了解这个属性的，永远是它所属的都对象。

面向对象就涉及到两个基本概念，一个是类（class）一个是对象实例（instance）。类其实是一个宽泛的概念，代表一种什么东西，比如人、美国人、中国人甚至王家沟人，它只是代表一个种类的概念，并不需要实体。而对象实例呢，则是一个具体的东西，比如王二狗和Tom，它表示的是一个实实在在的人，非常具体。我们可以说Tom是美国人，一个美国人叫Tom，Tom和美国人就是对象实例和类，对象实例需要依靠类来创建，而类其实就是多个对象实例相同特征的抽取。

    # Python中使用class关键字定义类(类名一般首字母大写)
    class PeopleFromWangJiaGou(object):
        # 后面的括号object，表示继承object类
        # 类中可以定义类自己的方法(函数)
        def __init__(self, name, age):
            self.name = name
            self.age = age
        # 该方法为特殊方法，在创建实例时自动调用，但创建的过程也会受到相应的限制，参数中self代表对象自己，self.变量名代表对象的某个属性
        # 对象也可以有别的方法,但是类中方法的必须有一个self参数,且是第一个参数
        def dianMing(self):
            print('%s 到' % self.name)
    
    # 创建上面类的对象实例,不需要self参数
    wangErGou = PeopleFromWangJiaGou('王二狗', 18)
    wangTieDan = PeopleFromWangJiaGou('王铁蛋', 19)
    # 想要知道对象的属性,问对象要就是了
    wangErGou.name
    wangTieDan.age
    # 也可以调用对象的方法,不需要self参数
    wangErGou.dianMing()
    wangTieDan.dianMIng()

面向对象有三大特征，封装、继承、多态。

#### 封装

封装就是将对象属性存在对象里面,因为当软件工程越来越大,鬼才知道你写的东西属性到底是个啥,解决这一问题就是把最了解这个对象的,从你自己这个创建者转移到对象自身。也就是说最了解、最清楚该对象的就是这个对象，而你也不需要知道对象里面到底是个啥，你只需要知道我需要这个属性、这个操作，找对象要就可以了。

#### 继承

继承其实就是类之间的一种关系。比如：

人可以作为一个类，它可以说话（speak），也可以扇自己嘴巴子（slap）

    # object类为Python中的超类，每个类都要继承这个类
    class People(object):
        def slap(self):
            print('piapiapia')
        def speak(self):
            print('hhh哈哈哈!@#$%%^^&ahfaij--我是火星文')

中国人、美国人，他们也可以说话，也可以扇自己嘴巴子，但是呢，重写一遍好难写哦，干脆复制粘贴吧。Python就提供了快速复制粘贴快捷键----继承，只需要在类定义时在其括号后加上基类的名字即可，好方便，还不如ctrl C、V呢。

    class ChinaPeople(People):
        pass
    class AmericanPeople(people):
        pass

继承之后，就有了一个问题，就是中国人不仅仅只是中国人了，美国人也不仅仅时美国人了，中国人、美国人都是人（黑人也是人）。是人当然可以扇自己嘴巴子，也可以说火星文。继承之后，子类拥有父类所有的属性和方法。

    liSi = ChinaPeople()
    liSi.speak()
    Tom = AmericanPeople()
    Tom.slap()

但是呢，中国人和美国人不能都说火星文，中国人应该说汉语，美国人应该说英语

    class ChinaPeople(People):
        def speak(self):
            print('你好')
    class AmericanPeople(people):
        def speak(self):
            print('hello')

通过在子类中对类方法进行重新定义，可以让子类的同名方法覆盖父类的方法，子类对象调用方法时，调用的是子类的方法

    liSi = ChinaPeople()
    liSi.speak()
    Tom = AmericanPeople()
    Tom.speak()

继承就是把父类的所有东西都拿过来，不需要写了，天生就有，典型的富二代，只需要发展自己特有的方法就可以了，也可以把老一套的东西换掉，换成新的东西。富二代还可以继续继承下去，生出富三代、富四代，而且只会越来越富。

继承“开闭”原则：

对扩展开放：允许新增子类
对修改封闭：不需要修改父类的方法，覆盖就行。

#### 多态

多态的意思就是一个对象实例，其实它可以属于多个类。比如王二狗，他是王家沟人，他们那里说话都是靠唱歌的

    class WangJiaGouPeople(ChinaPeople):
        def speak(self):
            print('呀拉索')
    wangErGou = WangJiaGouPeople()
    wangErGou.speak()

王二狗属于王家沟人，但是他同时也是中国人，同时也是人，这些都是他的身份，他可以当成间谍混入其中任一个组织中，但是他不是美国人，去美国当间谍可能会立马被抓。

    # 定义一个函数，需要参数为人
    def speak(People):
        People.speak()
    # 这时候有一个外星人，他就是说火星文的
    waiXingRen = People()

这时候我们有四个对象，人：waiXingRen、中国人：liSi、美国人：Tom、王家沟人：wangErGou。外星人是人，可以传到上面的函数中，那后面三个呢，他也是人，也可以当作People作为参数传进去。

    speak(waiXingRen)
    speak(liSi)
    speak(Tom)
    speak(wangErGou)

这就是多态，就是由于继承，一个对象可以有多个身份。

#### Python动态语言特性

如果是在Java中，对于一个参数类，它可以传入这个类的对象或者子类的对象，有严格的继承体系，比如和父类有直接关系，才能成为其子类，拥有父类的多态。

但是在Python这样的动态语言中，由于并不存在严格的类型检查，所以也不需要严格的去继承父类来实现多态，可以直接给一个类实现需要的函数，它就能直接实现相应的多态。

比如上面的speak需要传入一个People类的对象，这里重新定义一个类,不去继承People类

    class Bird(object):
        def speak(self):
            print('唧唧喳喳')

bird也能speak，对于上面的speak(People)函数，能speak就是People

    birdA = Bird()
    speak(birdA)

对于动态语言，没有严格的类型检查，“看起来像”就可以了，这就是“鸭子类型”。
    
## Python面向对象基础

#### 属性变量访问限制

所谓变量访问限制，就是像Java一样，设置私有变量、公共变量，但是Python并没有任何机制或者关键字来规定某个变量是不是私有变量，所有的变量按道理来讲应该都是公共变量。

但是Python还真就搞了一个不让你访问的私有变量出来，怎么实现的呢？难道又是“你不要过来”？不，这次更加高级一点儿。

    class StudentWangJiaGou(object):
        # 对于'_'（一个）开头的对象属性变量，就和之前的模块私有变量一样“你不要过来”。
        # 对于'__'（两个）开头的对象属性变量，有了一点儿区别，为了不让你访问，Python就把它伪装一下，换了一个名字，从外部直接访问这个变量就会发现没有这个东西
        def __init__(self, name, _gender, __age):
            self.name = name
            self._gender = _gender
            self.__age = __age
        
        # 设置私有变量之后，如果没有识破Python的伪装，想要访问私有变量怎么办呢？由于在对象内部是可以随意访问对象的属性的，所以我们可以让一个内部的公开的函数自己去访问它的私有变量，然后把私有变量的值传递出来，或者通过内部函数去设置对象的私有变量。
        # 最了解对象的是对象本身
        # 通过设置get/set方法访问和设置对象属性变量，这个思想不仅仅是用于私有变量，对于任何变量都可以设置相应的get/set方法
        def get__age(self):
            print(self.age)
        def set__age(self, age):
            self.__age = age

通过'__'两个下划线开头就可以设置私有变量，那为啥要设置私有变量呢，都是公有的，不是美滋滋，一个点啥都能访问，多美。设置私有变量其实感觉在Python中还是蛮重要的，因为Python没有类型检查，所以如果都是公共变量，一个点都能访问，而且配合Python变量类型可以随意更换，可以把任意别的类型复制给一个属性变量，这就会出现很多问题，可能你对象内部写得好好的函数，变量类型一改，可能就直接报错了。

而设置私有变量之后，不能直接访问了，在对象内部搞一个get/set方法，这就可以帮助我们很大程度的减少对于某些变量的类型进行修改，可以在get/set方法中进行类型检查、进行值的范围判断，限制属性变量的类型和大小，保证其他一些依赖这些变量的函数能够正常的运行。

**对于'\_\_'开头并且以'\_\_'结尾的变量是特殊变量，可以直接访问，一般用于系统表示某些参数**

另外由于Python对'__'开头的私有变量进行了伪装，换了一个名字，所以对象中是不存在该名字的属性的，如果直接对该属性进行赋值，可以正确的执行，但结果是新建了这个属性变量并赋值，并没有更改原来的私有变量。

如果你就是要直接访问这个私有变量，那就撕破Python的伪装吧。其实Python只是给室友变量改了一个名字，如果你要访问这个私有变量，可以使用以下形式直接访问

    # 对象._类名__私有变量名（私有变量名不包含前面的双下划线）
    ergou = StudentWangJiaGou('wangergou', 'm', 18)
    print(ergou.name)
    print(ergou._gender)
    # 报错没有这个属性
    # print(ergou.__age)
    print(ergou._StudentWangJiaGou__age) # 可以直接访问
    ergou.get__age()
    ergou.set__age(19)
    ergou.get__age()

#### 获取对象的属性（信息）

+ type(对象)

使用type()方法用于判断对象类型，返回其类Class，对于函数，也会返回对应的类

如果需要使用if来判断对象是不是某个类型，对于基本数据类型，type()返回的值是int、str等，可以直接使用这些类型名进行判断

    type(123) == int
    type("123") == str
    type(0.618) == float

对于某个类的对象，也类似

    class Bird(object):
        pass
    birdA = bird()

    type(birdA) == Bird

如果是函数，也会返回其对应的类，但是对于函数来说，类太多了，各种类，很难都记住类名，然后都写出来。这时候可以导入一个模块types，看名字就知道，它包含很多很多的类型

    import types
    def fn():
        pass
    
    type(fn) == types.FunctionType
    type(abs) == types.BuiltinFunctionType
    type(lambda x: x) == types.LambdaType
    type((x for x in range(10))) == types.GeneratorType

感觉还是挺难写的，还是别去判断这些东西吧

+ isinstance(对象实例, 类型表)

isinstance()方法也是判断对象的类型，只是它并不返回对象类型，它判断该对象的类型是不是后面类型表中的一个类型，返回True或False。

    isinstance('a', str)
    isinstance(123, int)
    isinstance(456, (str, int, float, list))
    isinstance([1, 2, 4], (list, int))
    isinstance((1, 2,3), (list, tuple))

另外对于一个类的子类的对象实例，因为多态的存在，判断结果也为True。

    isinstance(waiXingRen, People)
    isinstance(liSi, People)
    isinstance(Tom, People)
    isinstance(wangErGou, People)

这个时候，鸭子类型就没用了。

    isinstance(birdA, People)

+ dir(对象)

dir()方法类似window命令行环境下的dir命令（显示当前目录的文件和目录），dir()方法返回该对象的所有属性（方法也是属性）

类似__XXX__的属性和方法，Python都有特殊用途。比如__len__()即为获取对象的长度，当使用内置函数len(对象)时，其实就是直接调用对象的__len__()

    # 两者等价
    len('ASDF')
    'ASDF'.__len__()

如果想要自己写的类也可以直接调用len()方法来实现某个长度的操作（也可以是别的操作，只要你自己能记住），可以在类中复写__len__()方法，返回你想返回的长度。之后直接用内置函数len()调用也是执行复写之后的方法

  1. hasattr(对象, 属性名)

使用dir()方法，看到的很多都是没用的。可以使用hasattr()方法，测试该对象是否有这个属性

    hasattr('ASDFG', '__len__')
    'ASDFG'.__len__

  2. setattr(对象, 属性名, 设置的属性值)

setattr()方法可以设置对象的一个属性的值，其实和“对象.属性名 = 设置的属性值”一样。

  3. getattr(对象, 属性名, 默认返回值)

用于获取对象的这个属性，如果不存在默认返回值，且不存在这个属性则会报错。设置默认返回值之后，如果不存在这个属性，则返回默认值。

#### 实例和类的属性

对象上面的对象属性，其实都是对象实例的属性，也可以直接通过'对象.属性名 = 属性值'绑定一个新的属性，新的属性也是对象实例的属性。

而类其实也可以有类的属性，类的属性'类名.属性名'就是这个类共有的一个东西，这个类的所有对象实例都可以通过'对象.类属性名'访问到这个属性，但是它并不是对象实例所有，类的属性绑定在类上。

想要修改类的属性，可以通过'类名.类属性名 = 属性值'修改，如果使用类的一个对象访问，如'对象.类属性名 = 属性值'其实是在对象实例上绑定一个和类属性名同名的属性，再绑定一个同名属性之后，就不能通过'对象.类属性名'访问到类属性，访问到的会是绑定的对象实例属性。

>2020-6-9





