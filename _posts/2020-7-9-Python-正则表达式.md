---
layout:     post
title:      python 正则表达式
subtitle:   Python 正则
date:       2020-7-9
author:     ErYueSheng
header-img: img/post-sample-image.jpg
catalog:    true
tags:
    - python
    - 正则表达式
---

计算机涉及最多的数据结构一定是字符串，因为不管是你看到的、写出来的都是字符串。但是字符串如果随意些，可能会造成很多麻烦，在一些特定场合，字符串应该符合一些特定的规则。

正则表达式就是字符串的规则，凡是符合这个正则表达式列出的规则的字符串就认为字符串匹配了。

## 基本表达

正则表达式也是一串字符串，如何通过字符串来定义字符串呢？这需要一些代表某些字符的特定表达。

#### '\d' 匹配一个数字（0-9）
#### '\w' 匹配一个字母或者数字
#### '\s' 匹配一个空白的符号，如空格、制表符、换行等

    '00\d' 匹配'00(一个数字)'
    '\d\d\d' 匹配'(一个数字)(一个数字)(一个数字)'也就是'(三个数字)'

#### '.' 匹配一个任意字符

任意字符的意思是ascii码上有的，如果包含在正则表达式中，则表示这里有一个字符，也可以单独使用

#### '+' 匹配一个及以上个字符

不能单独使用，前面需要别的字符，表示前面的字符重复一次及以上。

#### '*' 匹配任意个字符

不能单独使用，前面需要别的字符，表示前面的字符重复任意次，包括0次。

#### '?' 匹配0个或1个字符

问号就是不确定是不是有，表示前面的字符可有可无。

这些基本表达可以相互组合，组合后需要按照从左到右依次解读。

## 进阶

如果需要表示很长且固定长的字符串，显然不可能将每一位都写出来。

#### '{n}'表示将前面的结构重复n次。

    '\d{100}' 匹配一个一百位的数字字符串
    '12345{4}' 匹配的是'12345555'

    '\d{1, 4}' 表示重复1至4遍,即匹配1-4个数字

#### 必须是3-7的数字，则使用'\[3-7\]'

    '[3-9]' 匹配一个3到9的数字
    '[a-c]' 匹配a,b,c其中的一个字符
    '[3-6a-hA-N]' 匹配其中包含的一个字符

    '[3-5]{1, 7}'表示前面匹配的范围内的字符再重复1-7遍

#### 对于选性的规则，用'|'来列出选择

    '[A|B]' 匹配'A'或者'B'

#### '^'表示开头

    '^\d' 表示必须数字开头

#### '$'表示结尾

    '\d$' 表示必须数字结尾

#### 特殊字符需转义

    如'_'、'-'等特殊字符需要使用'\_'、'\-'，即使用'\'来转义才能匹配，这里是正则表达式的转义

#### 特别说明

正则表达式如果表达的仅仅是有限个字符的规则，那么一个字符串前面的字符能够和正则表达式匹配，则字符串匹配了。

>20200709

# re模块

Python内置的re模块包含了所有正则表达式的功能。

*正则表达式本身也是一串字符串，代表一种规则，用来匹配字符串的规则*

**正则表达式本身也是一串字符串**

在Python中，字符串本身对于一些特殊字符也需要转义。

比如要匹配'ABC-123'这个字符串，则正则表达式字符串应该是这样'ABC\\\\-123'。第一个\\是Python字符串对特殊字符\\的转义表达，第二个\\是为了正则表达式匹配正则表达式中的特殊字符'-'而做的转义

现在这样书写老费劲了。所以建议用Python字符串的r前缀来表达字符串，r前缀表示后面的字符串不用转义。不用转义的意思是在Python字符串这一层不需要转移了。

使用r前缀，则上面的正则表达式变成了这样r'ABC\\-123'.

#### 匹配

使用re模块判断一个正则表达式和一个字符串是否匹配

    import re
    
    print(re.match(r'\d{3}\-\d{5}', '010-12345'))
    print(re.match(r'\d{3}\-\d{5}', '010-12345789'))
    print(re.match(r'\d{3}\-\d{5}', '12010-12345'))
    print(re.match(r'\d{3}\-\d{5}', '34010-12345789'))
    print(re.match(r'^\d{3}\-\d{5}', '010-12345789'))
    print(re.match(r'\d{3}\-\d{5}$', '34010-12345'))

re.match(正则表达式, 需要匹配的字符串)用以字符串的匹配，如果字符串是匹配的则会返回一个Match对象，否则返回None。

上面的运行结果如下：

    <re.Match object; span=(0, 9), match='010-12345'>
    <re.Match object; span=(0, 9), match='010-12345'>
    None
    None
    <re.Match object; span=(0, 9), match='010-12345'>
    None

自己分析，match方法常和if语句进行搭配，直接使用返回值作为条件判断，如果有值（Match对象）则为真，None即为假

    if re.match('正则表达式', '字符串'):
        pass
    else
        pass

#### 切分字符串

对于字符串切分，使用字符串对象的split函数即可完成，但是会存在一些问题

    print('A B     C'.split(' '))

切分结果会包含一些空格，使用正则表达式则可以更好的完成切分

    print(re.split(r'\s+', 'A B     C'))

结果只包含ABC三个字符，同时还可以对多种分隔符同时切分

    print(re.split(r'[\s\,\;\.\:]+', 'A  , .B ;:   C,.;D'))

#### 分组

在进行匹配的时候，还可以对正则表达式进行分组，分组之后匹配的同时会将分组也划分出来。使用小括号将正则表达式括起来即是一个分组。

    m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
    # 正则表达式有两个小括号，即又两个组
    print(m)
    print(m.group(0))
    print(m.group(1))
    print(m.group(2))
    print(m.groups())

group(0)返回的是匹配字符串，之后的1、2才是各个组的字符串。

    t = '19:05:30'
    m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
    m.groups()

#### 贪婪匹配

贪婪匹配就是正则表达式会尽量多的去匹配字符串，比如'\\d+'匹配一个以上的数字，则匹配时，如果有很多个数字，则都会被匹配

    print(re.match(r'^(\d+)(0*)$', '1022496420001623160000000000000000').groups())

前一组的'+'尽可能匹配了更多的字符串，然后就把所有的字符串全匹配了，导致第二组啥也没有。

如果要使用非贪婪匹配，则需要在'+'之后加一个'?'，这样后面的'0*'就能匹配到。

    print(re.match(r'^(\d+?)(0*)$', '10224420001623160000000000000000').groups())

#### 编译

Python中正则表达式的匹配过程分为两步，第一步是将正则表达式编译出来，判断正则表达式是否合法，之后再用编译好的正则表达式去匹配字符串。

因此对于一个正则表达式要多次重复使用时，可以提前将正则表达式编译出来，之后只负责匹配就行。

    # 编译:
    re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
    # 使用：
    re_telephone.match('010-12345').groups()
    re_telephone.match('010-8086').groups()

>20200710

