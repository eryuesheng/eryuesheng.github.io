---
layout:     post
title:      python3.8 基础学习日志
subtitle:   记录每天学习的python基础知识
date:       2020-5-30
authon:     ErYueSheng
header-img: img/post-sample-image.jpg
catalog:    true
tages:
    - python
---

>这是我自己写的第一篇博客，主要是大二期间有学过Java，然后发现两年后的今天，基本被我忘得差不多了，太难受了。于是我找了一位大佬的模板，搭了这个博客，开始记录学习过程，希望写博客能让我把很多东西记得更好，另外也整理一个自己的知识库，以后就算查起来也比较方便。

# Python3.8 语言基础

#### 学习之前

首先，我觉得尤其是现在做互联网这个方向的，要学的东西真的是越来越多了，不学基本就被淘汰了，其实非常难受，别人学点儿啥，工作一辈子，但是在互联网方向，可能你今天看着这个火，学了这个，明天可能那些大佬又搞出另一套更好的出来了，新出来的又火了，性能差的被淘汰了，或者没需求了。在这个方向吧，感觉真的需要活到老学到老，现在网上也很多的教程，但是呢，教程只要写出来，就定死了，但是很多东西是活的。我的意思呢，就是一定要善用度娘和谷歌大神，不懂就搜，虽然网上垃圾数据很多，但是有用的东西也不少，感觉度娘太垃圾，就用谷歌大神、bing等别的搜索。

#### 写在前面

本来呢，我打算写这个博客只是给自己看的，由于我大学期间已经算是很熟悉C语言了，所以很多基础的东西都不想写在这上面了。但是，万一哪天真有什么人看到这个了呢，而且以后可能还会从事教育这一方面，一些东西还是写清楚吧。当然，这些东西很简单，有过编程基础的，直接跳过。

首先说一下计算机存储的数据。计算机不会说话，内部也仅仅就是一些电路，肯定不会英文，也看不懂英语。那里面有什么呢？只有控制和存储，控制呢就相当于开关，数据就是一堆数了，就想象成简单的数字即可，比如几百几千几万啊，至于计算机内部如何存储这几百几千几万，就不关我的事情了，不用去了解，其实也没多大用。

数据没啥说的，说一下控制，这也是编程语言实现的部分，控制呢，其实就是开关，在电路上其实就是高低电平，简单的控制就是高电平实现一个功能，低电平实现一个功能。显然，现在的计算机+操作系统并没有有这么简单，其要控制的东西也不仅仅只是这两个功能，一个开关不够，只能搞很多个开关，那这很多个开关如何识别到底是哪一个呢？这就又是数据了。也就是说计算机和操作系统给这些开关编好号的，比如你要打开扬声器，系统会有一个打开扬声器的开关的编号，你知道这个编号，你按照操作把它搞成相应的状态就可以（可能是弄成高电平，也可能是弄成低电平）。

但是编程似乎便没有这么难，你也不需要知道哪个编号对应哪个开关。那怎么实现的呢？这就是大部分编译器和解释器的工作，人读不懂机器那种编号似的一堆堆数据，机器也看不懂英文，更别说中文了。怎么办呢？翻译机就出现了，就是将我们看得懂的，翻译成机器看得懂的，当然这里面涉及到很多知识，不讲了，没多大用，如果你要做操作系统，你要搞底层，那你学什么Python。

现在说一些这个翻译机。不管是啥，都是由限制的，比如说现实里面的翻译机，它可以实现中英翻译，这也是有针对性的，我也不可能拿着它去翻译德日法等其他语言。而编程中的翻译机也是如此，你必须按照它这个语言要求写代码，最后才能给你翻译正确。这个语言要求每种语言都不一样，所以你接触另一种语言就需要重新学一套。

就说这么多，只需要知道你根据相应语言要求写的代码需要特定的翻译机翻译成底层的机器能识别的一堆数据，就好了。旁边有我的联系方式，可以喷我，反正基本我也不看。

## 编程基础

### 基本数据类型

数据类型这个东西产生也是有原因的，因为人类发现计算机如果只能做整数计算，那可太浪费了。想让计算机啥都能算，咋办呢？搞一堆数据类型，计算机根据其类型完成相应的计算。

#### 整数

不说了，C语言还要分啥有符号没符号、长的短的，Python这里就是整数。

    a = 123

至于什么二进制、八进制、十六进制的表示方法，想看的自己去看吧，有时候写代码会方便一点儿，也没啥用，就写十进制一样的。

#### 浮点数

就是有小数点了。有小数点的结果就是小数点之后还有一堆数，至于为啥要叫浮点，想知道的自己去搜去看，屁用没有。

    d = 12.3456

这里说一下科学计数法，因为有时候一些数就是特别大，后面一堆0，看得人头昏眼花。上面的浮点也和科学计数法有一定关系，突然感觉自己又打开了一扇门，要讲好多东西，好难打字，难受。科学计数法把一个数分成了有效数字和阶数，举个例子：000000015603000.000000，写这么多零是为了更好的理解，它的有效数字就是把前面的和后面的0都去掉，当然中间的别动，剩下的就是有效数字，上面的有效数字就是15603，没有小数点，只是几个数而已。而阶数就和小数点在哪儿有关系了，先把上面的科学计数法形式写出来1.5603x10^7，乘号前面是有效数字，注意有一个小数点，其实前面是个小数，而后面的7就是阶数，因为前面的小数点其实可以换位置的，所以这个阶数也会跟着变化。在编程语言中，显然不会写什么'x10'，各种语言应该都定义了'e'，上面的科学计数法就成这样了1.5603e7。

    ds = 1.5603e7

#### 布尔类型

布尔类型其实就是开关而已，都是语言自己定义，python中使用True和False，其实就是真和假、开和关、1和0。

    flag = True

#### 字符串

Python里面不搞啥字符的，字符就是只有一个的字符串，全都是字符串，别搞那些花里胡哨的。字符串怎么表示呢？就用英文的单引号和双引号括起来即可，前面开头一个引号后面结束一个引号，可以是双引号也可以是单引号，但是全面都后面的引号必须是一样的，不然就牛头不对马嘴了。举个例子比如'abc'和"123"，注意这里的123不是数字一百二十三，而是符号串'123'，包含符号'1'和符号'2'和符号'3'。

    str = 'abcd'
    # 使用len方法计算字符长度，包含多少个字符
    len('abcd')

这里的符号是啥意思呢，其实在计算机看来也只是数而已。这里涉及到简单的编码知识。就跟之前我将的控制一样，计算机并不知道这个符号是什么鬼东西，但是大佬们就是定义了一套标准指定了，这个数就是什么符号，这其实就是编码，就是把一个符号对应一个数字，数字就能被计算机当成数据存储起来，相当于一个密码本也可以说就是翻译规则。

    # 使用ord('字符')函数用以获得该字符的数字表示
    ord('a')
    # chr(数字)用以获得该编码所对应的字符
    chr(65)

当然编码有很多，很多时候你运行一个应用，看到一堆乱码的时候，应该就是编码问题，因为密码本拿错了。内存中是用Unicode编码，包含全世界大部分国家的符号，打中文当然也是可以的。当然平时看到更多的应该是UTF-8，UTF-8和Unicode之间的关系我就不说了，想知道自行百度。也有些时候会发现程序出现莫名其妙的Bug，明明就是很简单的东西，程序也完全没问题，为啥就错了呢？可能就是你代码文件的编码出现了问题，我所遇到的最常见的就是Matlab代码编码问题，一堆稀奇古怪的东西。

    # 使用对象的encode方法可以将该字符串对象转换成想要的编码
    # 字符串.encode('编码方式')
    'ABC'.encode('ascii')

    # 也可以使用字节数据对象的decode方法将一个字节流数据转换成字符串，编码方式需和encode对应。
    # 字节数据.decode('编码方式')；
    b'ABC'.decode('ascii')

再说一下转义，转义是啥意思呢？就是世界上这么多国家总有一些特殊字符（比如打王者荣耀遇到的超越边界的昵称，这个不算特别特殊，至少能打得出来，有一些根本打不出来，比如制表符啊换行符啊这类东西），怎样才能在字符串中包含这个东西呢？这就是转义，用一个转义字符'\'来表示其后的字符未转移字符。比如要存入一个单引号，显然不可以直接用一个单引号，需要使用'\''，要存一个制表符就用'\t'，其他的自己类比或百度。

    print('\\\'\"\t\n\t\\\"')

#### 空值

空就是啥也没有，啥也不是，用'None'表示。不能将其理解成数字0，因为它不是数字，没有类型。

### 变量与常量

>好难啊，感觉好费劲啊，写个博客怎么这么难，要想怎么写，还要想怎么写更好理解，难受。

#### 变量

感觉自己废话连篇，主要是在考虑如果是啥基础也没有的人，如何快速读懂。写的很艰难，不想写这么多，哎，之后的还是按照自己能读懂，并且只是做一个小笔记那样写吧，写太多了难受。

变量就是自己定义一个符号，让这个符号表示某个数据。比如:

    a = 123

就是定义a这个变量，它的值是123。因为这个数据可以变化，我可以再写

    a = '123'

a的值就变成了符号串'123'，可以变化，所以是变量。

Python是动态语言，类型不需要写，也可以改变，其实将相当于C语言中的void指针，指向啥就是啥，只是不需要相关的指针操作。往深处讲就是编译原理了。

#### 常量

常量即使不会变的量，基本所有语言都是用全大写来表示常量。比如:

    PI = 3.1415926

但是呢，其实Python并没有任何机制来保证常量不改变，它其实就是变量，只是你自己这样写了，默认不去改变它。

#### 输入输出

所谓的输入输出是相对与内存的，输入就是往内存加数据，输出就是从内存拿数据出来，常用的输入输出就是键盘和显示器。

    # 使用print向显示器输出变量或字符串,自带换行。
    a = 100
    print(a)
    print("200")

    # 使用input从键盘输入数据
    a = input()
    print(a)
    a = input('请输入一个字符串：')
    print(a)

这里的input方法，返回的输入的数据都是字符串，不可以直接当成数值使用，必须根据相应的输入使用int()或float()方法对字符串进行转换。

#### 格式化字符串

使用格式占位符'%?'来为一个变量在字符串中占个坑，占了坑肯定就要有人来做事情，所以必须得再后面加上这个坑的内容

    # %d 为一个整数占个坑
    # %f 为一个浮点数占个坑
    # %s 为一个字符串占个坑，万能小丸子，不知道变量啥类型，就字节用这个就好了
    # %x 为一个十六进制整数占个坑，就是显示十六进制形式而已

    'hello number %d, your weight is %f kg, your name is %s' %(007, 75.5, 'tony')
    # '包含占位符的字符串' %(按顺序的占位符对应的数据，可以是变量，如果只有一个，可以省略括号)

    # 如果需要格式化字符串包含'%'，需要转义，不过不是'\%'，而是'%%'
    'percent rate: %d%%' % 98

假如我要规定浮点数保留几位有效数字、小数点后几位，一共显示几位等，需要给格式占位符加入参数

    # %[0][一共需要保留的位数].[小数点后需要保留的位数]d/f
    'percent:%05.2f%%' % 4.15623
    'percent:%0.1f%%' % 4.15623

第一个参数[0]表示如果该数的有效数字位数并没有需要保留的位数多，前面用0填充
第二个参数[一共需要保留的位数]表示这个坑一共需要保留多少为数字，包括小数点后的位数
第三个参数[小数点后需要保留的位数]必须配合前面的小数点，表示小数点后还需要保留多少位

还可以使用字符串对象的format方法依次将字符串中的占位符{0}、{1}..（不是上面的%?）替换掉,只是显然上面的方便一点儿。

    'hello number {0}, your weight is {1} kg, your name is {2}'.format(007, 75.5, 'tony')

>2020-5-30

### 数据结构

数据结构就是将一堆数据放在一起。

#### 列表：list

有序集合，可随时增加删除其中元素，使用[]将逗号分隔的各1元素括起来即可，长度可变，而且其中元素也可以是别的列表。

    # 初始化一个列表
    classmates = ['张三','李四','王二狗']
    # 使用len函数也可以计算列表元素个数
    len(classmates)

    # 列表相对于可变长的数组，利用索引即可访问每一个元素
    classmates[0]
    len(classmates[1])
    len(classmates[2])
    classmates[-1]
    # 也可以利用索引对某个元素重新赋值
    classmates[1] = '刘大爷'

    # 索引超出范围回报错
    classmates[3]

    # 使用list对象的append方法可以在list最后追加一个元素
    classmates.append('郑铁蛋')
    # 使用list对象的insert方法可以在一个元素插入所指定的位置，第一个参数为插入的索引位置
    classmates.insert(1, '李四')

    # 使用list对象的pop方法弹出list最后一个元素
    classmates.pop()
    # 也可以指定弹出相应索引位置的元素，参数为弹出的索引
    classmates.pop(2)

#### 元组tuple

list存在各种函数来修改元素的值，元素个数，也可以使用索引直接完成元素的替换，而元组tuple没有这些函数，也不能使用索引去修改元素。tuple就是一个不变的集合，初始化完成就不可以修改了。相比于list来说更安全。

使用()将用逗号分隔的元素括起来即为tuple。

    smallBox = ['book1', 'book2']
    # 定义一个tuple
    bigBox = (123, 'apple', smallBox)
    # 可以尝试修改tuple元素回出现错误
    bigBox[0] = 234

    # 尝试修改tuple内list中元素的值会发现tuple发生了变化，其实tuple并没有变化，每个元素的值并没有发生变化，只是这个元素是一个list，list元素中的元素发生了变化
    smallBox[0] = 234
    print(bigBox)

    # 定义一个空tuple
    tNull = ()
    # 如果要定义一个只包含一个元素的tuple，直接使用()括起来是不行的，应该再加一个逗号
    t = (123)
    tOne = (123, )
    # 这两个赋值得到的结果是不同的，第一个就是一个数字，第二个才是一个tuple

#### 字典dict

字典在很多语言中都叫做地图map，其实就是一堆键值对，键（key）和值（value)对应，可以通过键查找到其对应的值。

    # 初始化一个字典
    d = {'张三': 90, '李四': 85, '王二狗': 59}
    # 根据key查找其值
    d['王二狗']
    # 如果字典不存在这个key则会报错
    d['隔壁老王']
    # 为了避免报错，使用in来判断该key是不是在字典中存在，返回True则存在
    '隔壁老王' in d
    # 还可以使用字典对象的get方法，如果key不存在会返回None（啥也没有），或者自己指定的value
    d.get('隔壁老王')
    # 指定返回-1
    d.get('隔壁老王', -1)
    # 通过key添加一个键值对
    d['刘大爷'] = 0
    # 如果使用已经存在的key，则新数据会将原数据覆盖掉
    d['张三'] = 91
    # 要删除一个键值对，可以使用字典对象的pop方法，其参数为key
    d.pop('王二狗')

这里需要注意，其实字典使用的Hash算法，根据key查找Hash得到value的地址。所以字典中key必须使不可变的，因为变了，算法得到的地址也变了，自然也找不到原来的value。而且也很容易就会发现，一个字典里面不会存在两个相同的key。

#### 集合set

集合与字典中的key类似，就是一堆key，但是没有value。集合中没有相同的元素，而且各个元素之间也没有相对关系、前后关系。

    # 使用大括号将逗号分隔的元素括起来，即可组成一个set
    s = {0, 1, 2, 3, 3, 1}
    # 利用一个list来初始化一个set
    s = set([0, 1, 2, 3，3，1])
    # 通过set对象的add方法加入新的元素
    s.add(4)
    # 通过set对象的remove方法删除元素
    s.remove(3)

这里的集合和数学意义上的集合是一致的，也可以用交集（|）、并集（&）等操作

### 流程控制

#### 条件判断

使用条件判断之后的代码是不是执行

    # 形式：
    # if 条件表达式1:
    #     条件1判断为True执行的代码
    # [elif 条件表达式2:
    #     条件2判断为True执行的代码
    # ...
    # else:
    #     上面的条件都不满足执行的代码]
    # elif-else部分为可选项，而且如果有多个条件，是一个接一个顺序判断的

    age = 13
    if age < 18:
        print('小年轻')
    elif age < 30:
        print('小青年')
    elif age < 45:
        print('中年')
    elif:
        print('中老年')

#### 循环

for循环利用迭代的原理从list或者tuple中遍历每一个元素，以此进行每一个循环

    # 形式：
    # for 循环内部用于迭代的变量 in list变量或tuple变量或range对象:
    #     循环代码块
    for x in ['张三','李四','王二狗']:
        print(x)
    
    # 对于普通的数字list，如果直接用上面的方式写，可能会很长。可以利用range函数返回一个数字序列
    # 函数形式1：range(begin, stop[, step]) 返回从begin(包含)按step步长(默认为1)到stop(不包含)的一个数字序列
    # 函数形式2：range(stop) 返回从0到stop(不包含)步长为1的数字序列
    sum = 0
    for x in range(101):
        sum = sum + x
    print(sum)

while循环，根据条件判断是不是执行循环代码

    # 形式：
    # while 条件表达式:
    #     循环代码
    # 循环代码内应包含使条件发生改变的代码或用break跳出，不然可能就是死循环
    sum = 0
    n = 1
    while n <= 100:
        sum = sum + n
        n = n + 1
    print(sum)

break跳出循环，执行循环之后的代码。通常需要配合条件判断
continue跳过本次循环之后的代码，执行下一次循环

### 函数

函数就是将一个特定的功能封装起来，方便使用

#### 自带函数

每种语言都又一些自带的函数，方便使用，[这里](https://docs.python.org/3/library/functions.html)是Python自带的函数，可以收藏方便查阅。除了这些内置函数外，其实之前就还接触了另一种函数，就是对象的方法（函数），像list对象的insert方法等等。这些自带函数通过文献都可以查阅到。

#### 定义函数

Python中定义函数使用def语句，返回值使用return语句

    # 形式:
    # def 函数名(参数表):
    #     函数执行的代码
    def myMax(x, y, z):
        if x > y:
            if x > z:
                return x
            else:
                return z
        else:
            if y > z:
                return y
            else:
                return z
    # 如果函数不需要返回值，则直接使用return，当函数执行到最后时，如果没有return，也会自动返回

pass语句用于占用一个来不及写代码的位置，代替来不及写的代码块。由于python代码利用缩进来确定代码所属的代码块，如果有些代码块定义了但是没写出来就会报错语法错误，利用pass语句就可以跳过这个代码块，将程序运行起来。类似于Java中的//TODO，只是TODO只是注释可写可不写，而Python中必须写。

    def nop():
        pass

在Python中，可以实现一个函数返回多个值，如下形式

    # return x, y

其实也是类似C语言返回指针，Python返回的其实是一个tuple，将多个值组合成一个tuple然后返回。调用接收返回值时，可以用如下形式

    # 使用对应的两个值来接收，按顺序将返回值赋值给两个值
    # x, y = fun()
    # 也可以只是用一个值来接收，这是接受到的是一个tuple
    # t = fun()

#### 函数参数

在Python中，定义函数时可以使用多种特殊的参数，为函数编程提供了很多方便。

位置参数：位置参数就是按参数表的位置传入的参数，上一节中所有的参数都是位置参数。在函数调用时，位置参数都比如按相应位置传入，为必选参数。

默认参数：默认参数就是在调用函数时，可以不传入这个参数，函数内部会有一个默认值，按默认值进行计算。默认参数的默认值一般设置为不可变对象，如果设置成可变对象，可能会出现类似C语言静态局部变量的情况。

    # 默认参数的定义形式如下，x是位置参数，n是默认参数
    def power(x, n = 2):
        pass
    # 函数调用时使用power(4)时，会默认n = 2

可变参数：可变参数就是参数个数不确定，可以发生改变，其实和返回多个值一样，就是一个tuple。

    # 可变参数使用如下,args即为可变参数，在函数内部将其当作一个tuple处理
    def max(*args):
        pass
    # 函数调用时参数可以写任意个
    max(1, 2, 3, 4)
    # 如果对于一个已经存在的list或tuple，将其作为参数，其对应的函数调用如下，只需要在其前加一个*（类似C语言取地址）
    aList = [0, 1, 2, 3, 4]
    max(*aList)
    
关键字参数：关键字参数就是一个字典dict。

    # 定义如下，kw就是关键字参数，可以传入0个或多个关键字参数
    def student(name, age, **kw):
        pass
    # 相应的调用如下
    student('王二狗', 18, gender = '男', city = '八里村')
    # 如果对于一个现成的dic他，想要其作为参数，只需要在其前加上连个*
    d = {'gender': '男', 'city': '八里村'}
    student('王二狗', 18, **d)

命名关键字参数：就是限制关键字参数的key，规定关键字参数的key必须是所规定的那样。命名关键字参数和位置参数一样，如果定义了，那调用时必须传入。当然也可以使用默认参数对其进行赋值。

    # 命名关键字参数
    def student(name, age, *, gender, city):
        pass
    # gender和city即为命名关键字参数，他规定必须传入两个关键字参数，他们的可以分别是gender和city。命名关键字参数在一个“*，”之后，其实那个*那里应该是一个可变参数，只是如果不需要可变参数，就不写参数名，当*号必须写，不然后面的就是普通的位置参数了。

参数组合：以上的这些参数都可以组合使用，但是其顺序必须是：位置参数、默认参数 、可变参数、命名关键字参数、关键字参数。当然，函数定义时还是尽量别搞这么复杂，多难受啊。

>2020-5-31
    
## 高级特性

Python自己定义的一些特性，旨在提高开发效率，绝不多写一行代码。

#### 切片

类似matlab的取子矩阵。Python可以对list、tuple、字符串也进行这样的操作

    # 形式如下
    # L为一个list或tuple或字符串
    L[begin: end: step]
    # begin为开始下标，end为结束下标（不包含），step为步长（可选，默认为1）
    # 如果begin为0，则形式可以简化，省略begin
    L[: end]
    # 也可以取倒数几个，使用负数，如下
    L[-begin: -end：step]
    # 上式为取倒数第begin个至倒数第end个（不包含）
    # 如果end为0，-end也可以省略

对于list、tuple、字符串都可以进行上述操作

#### 迭代

迭代就是对一个容器内的元素进行遍历，Python中使用for...in就能完成。首先in后面的容器对象应该是可迭代的，list、tuple、dict、set、字符串都是常见的可迭代对象

    # 判断对象是否为可迭代对象
    # 需要导入Iterable
    from collections.abc import Iterable
    isinstance(对象， Iterable) # 判断对象是否可迭代

    # 对于字典d，其直接迭代结果是迭代其键key，如果要迭代其值value，需要使用d.values()，如果要迭代键值对，需要使用d.items()
    for key, value in d.items():
        pass

    # 如果想在迭代过程中获得元素的下标，使用Python内置的enumerate函数
    for index, value in enumerate(aIterableObj):
        pass
    
    # 当然如迭代字典中的键值对一样，可以同时迭代对各变量
    for x, y in [(1, 1), (1, 2), (2, 3)]:
        pass

#### 列表生成/列表解析

列表生成就是为了更简单的生成一个特定的列表，其实类似数学表达式。

    # 列表生成形式：最外层的括号为中括号则生成列表，为大括号则生成集合，不能生成tuple，因为小括号就是后面说到的生成器。if 筛选条件项为可选项，筛选是只将符合条件的变量代入表达式，注意没有else
    # [表达式 for 变量 in 可迭代对象 [if 筛选条件]]
    [x * x for x in range(1, 11) if x % 2 == 0]
    # 对于表达式中包含多个变量的情况，可以使用多个for...in

    # 在表达式中也可以使用条件判断if...else...来生成更多形式的列表，但是注意，这里只是根据条件生成不同的列表，变量信息由后面的for...in决定，所以这里必须有else，形式如下：
    # [表达式1 if 判断条件 else 表达式2 for 变量 in 可迭代对象 [if 筛选条件]]

#### 迭代器

前面降到了可迭代对象Iterable，可以使用for...in迭代对下个中的元素。其实for...in遍历元素通过可迭代对象的迭代器去完成的，迭代器对象就是支持迭代器协议的对象，迭代器协议就是实现对象的__iter__()和next()方法，__iter__()方法返回迭代器对象本身，next()方法返回容器的下一个元素，不存在下一个元素时抛出StopIteration异常。实现上面的两个方法就可以自定义一个迭代器对象。当然，迭代器对象也可以使用for...in来遍历。

    # 可以通过isinstance(待判断的对象，类型)方法来判断一个对象是不是Iterator对象
    isinstance([], Iterator)
    # 可迭代对象并不是迭代器

对于可迭代对象，可以使用内置函数iter()来获得对应的迭代器对象，然后就可以通过next(迭代器对象)方法获得可迭代对象的元素。

    # 使用iter(可迭代对象)方法获得迭代器对象
    L = [0, 1, 2, 3, 4]
    it = iter(L)
    # 使用next(迭代器对象)访问下一个元素
    next(it)
    # 可以使用list()方法直接获得之后所有的迭代结果，返回一个list
    list(it)

#### 生成器

在某些情况下，我们不希望生成整个列表，我们可以选择使用生成器，当我们想要获得下一个列表项时，现场给我们计算出来，节省存储空间。常见的得到生成器的方式有两种，一是列表生成，将最外层的括号换成小括号即可，称为生成器表达式。另一种对于复杂的表达式生成，可以写一个生成器函数，利用yield将函数中需要的列表项传递出来。

    # 利用列表生成表达式得到生成器
    # (表达式 for 变量 in 可迭代对象 [if 筛选条件])
    # 利用生成器函数来创建生成器
    # 利用yield传递出你想要生成序列的变量
    def fib(max):
        n, a, b = 0, 0, 1
        while n < max:
            yield b
            a, b = b, a + b
            n = n + 1
        return 'done'

    # 得到生成器之后，可以使用next(生成器对象)来获得生成器的下一个值，没有下一个值是会报错
    # next(生成器对象)
    # 更常用的是使用for...in来完成全部的迭代，不用去关心有没有下一个值
    # for n in 生成器对象:
        pass
    
    # 利用生成器生成序列值后，是拿不到函数的返回值的。如果需要返回值，需要用next方式，并捕获StopIteration错误中的value。

这里在说一下生成器函数执行流程，当你得到生成器对象之后，调用next函数，其实就是运行函数，函数遇到yield语句之后发生中断，把值传递出去，下一次调用next函数，会回到上一次的中断，继续执行下去，知道遇到下一个yield再次中断或函数运行结束。

其实生成器函数的返回值就是生成器的迭代器，生成器就是一种特殊的迭代器，所以也同样存在next()方法。

## 函数式编程

### 高阶函数

函数名其实就是指向函数代码地址的变量，类似C语言的函数指针。Python中函数名可以做为参数传入另一个函数，则另一个函数被称作高阶函数。

#### map/reduce

map/reduce为两个编程模型，以简化复杂计算，在这里就是两个高阶函数。

map就是对一组数据进行相同的操作，Python中map函数需要传入两个参数，第一个是对数据进行的操作，第二个是可迭代的对象，里面装着需要操作的元素。map函数的返回值是一个迭代器，可以使用list以此迭代完全部的序列。

    # 形式：
    # map(操作函数名, 可迭代对象) 返回一个迭代器
    # list(map(操作函数名, 可迭代对象)) 以此完成所有的迭代

reduce是一种函数的嵌套形式

    reduce(f, [x1, x2, x3, x4, x5]) = f(f(f(f(x1, x2), x3), x4), x5)

Python中使用reduce需要从functools模块导入reduce，reduce函数第一个参数为执行的操作，第二个参数为一个可迭代对象。

    # 导入reduce
    from functools import reduce
    # reduce(操作函数名, 可迭代对象) 返回值为嵌套函数的最终返回值

map、reduce可以嵌套使用以实现更好的效果。

>2020-6-2

#### filter

filter就是滤波器，同样可以传入两个参数，一个函数一个序列，函数就是一种滤波规则，返回True则保留该元素，返回False则丢弃该元素。filter函数最后的返回值也是一个迭代器，一次只产生一个值

    # 首先需要一个函数f，其返回值为一个布尔值
    def 函数名(元素):
        ...
        return 条件表达式
    # 然后使用filter对某一序列进行筛选，返回筛选之后的结果
    filter(函数名, 可迭代序列)

#### 排序

排序算法是非常常见的，Python使用sorted()函数对一个Iterable进行排序，为了实现更多的排序功能，该函数可以接收两个命名关键字参数key和reverse。sorted本身只是对数字从小到大、字符串ascii码从小到大的排序（对于中文字符的排序还不太明白），并不接受其他的功能，如果想要定义类似绝对值排序、忽略大小写的排序时，需要使用key关键字传入一个函数，实现取绝对值、大小写转换等操作。如果需要从大到小的排序，则需要将reverse关键字赋值为True。

    # 对一个简单的list进行排序
    sorted([36, 5, -12, 9, -21])
    # 排序时按照绝对值进行排序
    sorted([36, 5, -12, 9, -21], key = abs)
    # 反向排序
    sorted([36, 5, -12, 9, -21], key = abs, reverse = True)

>2020-6-3

